/*
  _________| array | linked list |
  чтение   | O(1)  |    O(n)     |
  вставка  | O(n)  |    O(1)     |
  удаление | O(n)  |    O(1)     |
  ________________________________

*/


/*  Exercise 2.1
      Допустим, вы строите приложение для управления финансами.
      Ежедневно вы записываете все свои траты. В конце месяца вы анали- зируете расходы
      и вычисляете, сколько денег было потрачено.

      При работе с данными выполняется множество операций вставки и относительно немного операций чтения.
      Какую структуру использовать — массив или список?

    Answer:
      Lined List
*/

/*  Exercise 2.2
      Допустим, вы пишете приложение для приема заказов от посетителей ресторана.
      Приложение должно хранить список заказов. Официанты добавляют заказы в список,
      а повара читают заказы из списка и выполняют их. Заказы образуют очередь:
      официанты добавляют заказы в конец очереди, а повар берет первый заказ из очереди и начинает готовить.

      Какую структуру данных вы бы использовали для реализации этой очереди: массив или связанный список?

    Answer:
      Lined List. Удобнее, так как мы можем сохранять ссылки на первый и последний элемент списка
*/

/*  Exercise 2.3
      Допустим, вы пишете приложение для приема заказов от посетителей ресторана.
      Приложение должно хранить список заказов. Официанты добавляют заказы в список,
      а повара читают заказы из списка и выполняют их. Заказы образуют очередь:
      официанты добавляют заказы в конец очереди, а повар берет первый заказ из очереди и начинает готовить.

      Какую структуру данных вы бы использовали для реализации этой очереди: массив или связанный список?

    Answer:
      Array
*/

/*  Exercise 2.4
      Пользователи также довольно часто создают новые учетные записи на Facebook.
      Предположим, вы решили использовать массив для хране- ния списка пользователей.
      Какими недостатками обладает массив для выполнения вставки?
      Допустим, вы используете бинарный поиск для нахождения учетных данных.
      Что произойдет при добавлении новых пользователей в массив?

    Answer:
      Бинарный поиск требует на вход отсротированный массив. В таком случае придется всегда сортировать массив перед поиском
      если мы будем добавлять нового пользователя в конец. Также возможен вариант сортировки массива сразу же после добавления
      нового пользователя и затем уже сохранить результат.
      Есть и третий вариант, сохранять пользователя сразу же по нужнему индексу.

      В любом случае, все три варианта кажутся не оптимальными.
*/

/*  Exercise 2.5
      В действительности Facebook не использует ни массив, ни связанный список для хранения информации о пользователях.
      Рассмотрим гибридную структуру данных: массив связанных списков. Имеется мас- сив из 26 элементов.
      Каждый элемент содержит ссылку на связанный список. Например, первый элемент массива указывает на связанный
      список всех имен пользователей, начинающихся на букву «A». Второй элемент указывает на связанный список всех
      имен пользователей, на- чинающихся на букву «B», и т. д.

      Предположим, пользователь с именем «Adit B» регистрируется на Facebook и вы хотите добавить его в список.
      Вы обращаетесь к элементу 1 массива, находите связанный список элемента 1 и добавляете «Adit B» в конец списка.
      Теперь предположим, что зарегистрировать нужно пользователя «Zakhir H». Вы обращаетесь к элементу 26,
      который содержит связанный список всех имен, начинающихся с «Z», и проверяете, присутствует ли «Zakhir H» в этом списке.

      Теперь сравните эту гибридную структуру данных с массивами и свя- занными списками.
      Будет ли она быстрее или медленнее каждой ис- ходной структуры при поиске и вставке?
      Приводить «O-большое» не нужно, просто выберите одно из двух: быстрее или медленнее.

    Answer:
      Да, будет. Но поиск все же бует O(n), так как мы не можем использовать бинарный поиск, но в любом случае
      он будет быстрее, чем в одном большом Linked List.
*/
